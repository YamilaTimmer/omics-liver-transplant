---
title: "Logbook 2.4.1 Omics (DEA with limma)"
author: "Yamila Timmer"
date: "`r Sys.Date()`"
output:
  word_document:
    toc: true
    toc_depth: '3'
  html_document:
    toc: true
    toc_depth: '3'
    df_print: paged
  pdf_document:
    toc: true
    toc_depth: '3'
lang: eng
---

# Load libraries
```{r, warning = FALSE, message = FALSE}
library(pathview)
library(tidyverse)
library(readxl)
library(DEP)
library(SummarizedExperiment)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(clusterProfiler)
library(limma)
library(ggrepel)
library(ggplot2)
```

meta_data <- read.delim("../../../E-MTAB-13501.sdrf.txt")

File below contains metadata from transcriptomics. Source name refers to the FASTA ID's (transcriptomics), characteristics individual refers to liver number (I think?), possible interesting metadata to keep: age, sex,


# Introduction
The article we have been assigned is "Bile proteome reveals biliary regeneration during normothermic preservation of human donor livers" (@thorne2023bile). Individually we have read the article and divided the tasks. My tasks include:

- Primary analysis of data
- Normalisation & imputation of data
- Differential expression analysis

I ended up only working with the proteomics data, as the transcriptomics data proved to be of insufficient quality. The proteomics data consists of bile samples taken from extended criteria donors (ECD), taken at three different time points after starting normothermic machine perfusion (NMP), at 30 and 150 minutes for the livers that end up not being transplanted (due to insufficient quality) and at 30, 150 minutes and before transplantation (timepoint: "end") for livers that did end up being transplanted. We will only work with the 30/150 minute samples as the 'end' timepoints consist of less samples and could skew the data as presumably only livers with higher quality get transplanted.

One of the traits that can be used to determine whether an ECD liver is suited for transplantation, is the "biliary viability". This tells something on the quality of 'cholangiocytes', which are epethilial cells of the bile ducts. Higher biliary viability meaning the ECD liver is less likely to develop post-transplantation conditions such as cholangiopathy. A problem with this approach is that there are no set measurements for biliary viability, the way it gets measured varies per institute and consists of mostly physiological factors such as bile pH. 

Our goal is to get a better understanding of biomarker profiles in low/high biliary ECD livers and we hope to achieve this through a variety of methods including a differential expression analysis (DEA), principal component analysis (PCA), Partial Least Squares Discriminant Analysis (PLS-DA) and a confusion matrix.

Our research question is: "What bile- and liver- biomarkers correlate with biliary viability of ECD livers"

# Data
For proteomics, we have various data files, including:
- *NMP_Bile_Proteomics_Report.txt* (.tsv): contains identified + quantified protein counts, rows = proteins, columns = sample ID.
- *supp_data.xlsx*, figure 3a: contains metadata, including sample ID, liver number and time point the sample was taken at.
- *supp_data.xlsx*, figure 4a: contains metadata, including sample ID, liver number and biliary viability.

By joining figure 3a/4a together from *supp_data.xlsx*, the required metadata for our research question can be retrieved.

```{r}
# Load count data from .txt file
data <- read.delim("../../../NMP_Bile_Proteomics_Report.txt", header = TRUE)

# Loading figure 3a + 4a from the supp_data excel file
sup_data1 <- read_excel("../../../supp_data.xlsx", sheet = "Figure 3a", col_names = TRUE, skip = 4, trim_ws = TRUE) # skip lines so the empty excel lines are not left in

sup_data2 <- read_excel("../../../supp_data.xlsx", sheet = "Figure 4a", col_names = TRUE, skip = 3, trim_ws = TRUE) # skip lines so the empty excel lines are not left in
```


## Creating metadata dataframe
```{r}
# Retain only the columns containing metadata
sample_id1 <- sup_data1[c("Sample", "Liver number", "Timepoint")]

sample_id2 <- sup_data2[c("Sample", "Biliary viability score group", "Total BDI score group", "Transplant")]
```

Next both dataframes are merged by the common 'Sample'-column, only the samples are kept that are in both dataframes (by using inner_join). sample_id1 seems to contain more samples than sample_id2, so it is expected the resulting merged dataframe will contain as many rows as sample_id2, assuming all of the samples of sample_id2 are also in sample_id1.

```{r}
print(paste("Amount of samples in sample_id1:", length(rownames(sample_id1))))
print(paste("Amount of samples in sample_id2:", length(rownames(sample_id2))))

# Only merges when sample ID is in both dataframes, leaves some livers out as there seems to be some missing data
merged_sample_id <- inner_join(sample_id1, sample_id2, by = "Sample")

print(paste("Amount of samples in merged dataframe:", length(rownames(merged_sample_id))))
```
**Conclusion**: The resulting dataframe indeed contains as many rows as sample_id2, some samples have been lost due to their absence in sample_id2 and cannot be used as there is no biliary viability label for them, however 114 samples should be enough to proceed with our research.


## Pre-processing steps

The colnames of the count data are very long (e.g."X.2..NMP_Bile_Proteomics_171.raw.PG.Quantity") and can be shortened using some regex, to make the names easier to work with, this is also needed because the sample names have to be the same as the format in the metadata (NMP_Bile_Proteomics_171), in order to filter on samples later on.

```{r}
colnames(data)[4:ncol(data)] <- sub(".*?(NMP_Bile_Proteomics_[0-9]+).*", "\\1", colnames(data)[4:ncol(data)]) # regex that removes everthing, but the "NMP_Bile_Proteomics_X" identifier and replaces colnames of data with this, we need that to match it to the metadata
```

In order to convert the data to a SummarizedExperiment-object (which is needed for imputation and comparing across groups), the data needs two columns: one with the gene names and one with a unique identifier that gets made with `make_unique`.
```{r}
# adds unique identifier columns based on name/id columns
data_unique <- make_unique(data, 
                           names = "PG.Genes", 
                           ids = "PG.ProteinAccessions", 
                           delim = ";")
```

### Filtering samples

We will only be using 30/150min samples and these will be filtered in seperate dataframes as we will be comparing low vs high biliary viability in the 30 minute samples and in the 150 minute samples. "End" samples are removed.

Filter 30 min samples
```{r}
# Filter only the 30 min samples from metadata
samples_30min <- merged_sample_id$Sample[merged_sample_id$Timepoint == "30min"]

# Columns to keep in count data
cols_30min <- c("ID", "name", "PG.ProteinGroups", "PG.Genes","PG.ProteinAccessions", samples_30min)

# Subset on count data/metadata
samples_30min_data <- data_unique[, colnames(data_unique) %in% cols_30min]
samples_30min_metadata <- merged_sample_id[merged_sample_id$Sample %in% samples_30min, ]
```

Now repeat for 150 min samples
```{r}
# Filter only the 150 min samples from metadata
samples_150min <- merged_sample_id$Sample[merged_sample_id$Timepoint == "150min"]

# Columns to keep in count data
cols_150min <- c("ID", "name", "PG.ProteinGroups", "PG.Genes","PG.ProteinAccessions", samples_150min)

# Subset on count data/metadata
samples_150min_data <- data_unique[, colnames(data_unique) %in% cols_150min]
samples_150min_metadata <- merged_sample_id[merged_sample_id$Sample %in% samples_150min, ]
```

Replacing NaN values with NA, which is needed for further analysis
```{r}
# Convert NaN to NA, which is neccessary to create SE object and for normalisation
samples_30min_data <- samples_30min_data %>% mutate_all(~ifelse(is.nan(.), NA, .))
samples_150min_data <- samples_150min_data %>% mutate_all(~ifelse(is.nan(.), NA, .))
```

# Creating Summarized Experiment

A lot of R-packages for normalisation/imputation and differential expression analysis work with SummarizedExperiment objects, so I will be converting the data to that format. First an 'experimental design' has to be made, containing information on sample ID, condition and replicate info. With the condition being the biliary viability. In our research there are no replicates.

Making experimental design for 30 min
```{r}
# Vector with sample column numbers
sample_columns_30min <- grep("NMP.", colnames(samples_30min_data))

experimental_design_30min <- data.frame(
  label = colnames(samples_30min_data[, sample_columns_30min]), # has to match colnames of samples 
  condition = samples_30min_metadata$`Biliary viability score group`,
  replicate = colnames(samples_30min_data[, sample_columns_30min]) # there are no replicates in this case, but they still need a unique identifier because duplicate rownames are not allowed
)
```

Making experimental design for 150 min
```{r}
# Vector with sample column numbers
sample_columns_150min <- grep("NMP.", colnames(samples_150min_data))

experimental_design_150min <- data.frame(
  label = colnames(samples_150min_data[, sample_columns_150min]),  #has to match colnames of samples 
  condition = samples_150min_metadata$`Biliary viability score group`,
  replicate = colnames(samples_150min_data[, sample_columns_150min]) # there are no replicates in this case, but they still need a unique identifier because duplicate rownames are not allowed
)

```

Create summarized experiment
```{r}
data_se_30min <- make_se(samples_30min_data, sample_columns_30min, experimental_design_30min)

data_se_150min <- make_se(samples_150min_data, sample_columns_150min, experimental_design_150min)
```


# Removing Samples/Proteins with high missing values
```{r}
mean_missing_percentage_samples_30min <- colMeans(is.na(assay(data_se_30min))) * 100

mean_missing_percentage_samples_150min <- colMeans(is.na(assay(data_se_150min))) * 100

bad_samples_30min <- names(mean_missing_percentage_samples_30min[mean_missing_percentage_samples_30min > 70])


bad_samples_150min <- names(mean_missing_percentage_samples_150min[mean_missing_percentage_samples_150min > 70])

data_se_30min <- data_se_30min[, !colnames(data_se_30min) %in% bad_samples_30min]

data_se_150min <- data_se_150min[, !colnames(data_se_150min) %in% bad_samples_150min]

```

Median centering to normalize across samples (columns)

```{r}
# Sample medians visibly differ from eachother, so median centering will have to be performed to remove noise between samples
plot_normalization(data_se_30min)
plot_normalization(data_se_150min)

```
```{r}

median_centering <- function(data){
  # Calculate median per column
  colmed <- apply(assay(data), 2, median, na.rm = TRUE)
  
  # Remove sample median from all features, to centre data around median = 0, to correct for differences between samples
  med_normalized_samples <- sweep(assay(data), 2, colmed, "-")
  
  # Place sample-adjusted data back in summarized experiment
  assay(data) <- med_normalized_samples
  
  # Visualize data after sample normalizing
  plot_normalization(data)
}

median_centering(data_se_30min)
median_centering(data_se_150min)

```




```{r}
# Keep all proteins with at least 30% presence across all samples (based on mean_protein_presence)
data_se_30min_filter <- filter_proteins(data_se_30min, type = "condition", thr = 4)

data_se_150min_filter <- filter_proteins(data_se_150min, type = "condition", thr = 4)
```

```{r}
# Calculate the median average presence of proteins per sample, in the article this was 41.5%
mean_protein_presence_30min <-  mean(rowMeans(!is.na(assay(data_se_30min)))) * 100
mean_protein_presence_30min

mean_protein_presence_150min <- mean(rowMeans(!is.na(assay(data_se_150min)))) * 100
mean_protein_presence_150min
```

# Normalisation

```{r}
data_norm_30min <- normalize_vsn(data_se_30min_filter)
data_norm_150min <- normalize_vsn(data_se_150min_filter)
```

```{r}
meanSdPlot(data_norm_30min)
meanSdPlot(data_norm_150min)
```

```{r}
plot_frequency(data_norm_30min)
plot_frequency(data_norm_150min)
```
```{r}
plot_detect(data_norm_30min)
plot_detect(data_norm_150min)
```

On average the missing values come from proteins with low intensities (points to MNAR), an imputation method that is suited for this is (“QRILC”) quantile regression-based left-censored function

After imputation with QRILC, a second "top" exists, with low intensity, this is because it fills NA values with low intensity values that were failed to be measured in the first place (MNAR)

# Imputation
```{r}
data_imp_30min <- DEP::impute(data_norm_30min, fun="MinDet")
data_imp_150min <- DEP::impute(data_norm_150min, fun="MinDet")

```
plsda als histogram of componenten weergeven met scatterplot

```{r}
plot_pca(data_imp_150min, indicate = "condition")
plot_pca(data_imp_30min, indicate = "condition")
```


```{r}
plot_imputation(data_norm_150min, data_imp_150min)
plot_imputation(data_norm_30min, data_imp_30min)
```

```{r}
design <- model.matrix(~ condition, data = colData(data_imp_150min))

# Function for differential expression analysis (DEA) with limma
limma_fit <- function(data){
  # high = intercept
  design <- model.matrix(~ condition, data = colData(data))
  
  # Fit linear model to each protein
  fit <- lmFit(assay(data), design)
  # Empirical Bayes smoothing
  fit <- eBayes(fit)
  # Apply false fiscovery rate correction
  limma_results <- topTable(fit, adjust.method = "fdr", number = Inf)
}

# Run on both time datasets
limma_results_150min <- limma_fit(data_imp_150min)
limma_results_30min <- limma_fit(data_imp_30min)

```

```{r}
# add a column of NAs
limma_results_150min$diffexpressed <- "NO"
# if log2Foldchange > 1.0 and pvalue < 0.05, set as "UP" 
limma_results_150min$diffexpressed[limma_results_150min$logFC > 1.0 & limma_results_150min$adj.P.Val < 0.05 & limma_results_150min$P.Value < limma_results_150min$adj.P.Val] <- "DOWN"
# if log2Foldchange < -1.0 and pvalue < 0.05, set as "DOWN"
limma_results_150min$diffexpressed[limma_results_150min$logFC < -1.0 & limma_results_150min$adj.P.Val < 0.05 & limma_results_150min$P.Value < limma_results_150min$adj.P.Val] <- "UP"

limma_results_150min$difflabel <- NA
limma_results_150min$difflabel[limma_results_150min$diffexpressed != "NO"] <- rownames(limma_results_150min)[limma_results_150min$diffexpressed != "NO"]


# add a column of NAs
limma_results_30min$diffexpressed <- "NO"
# if log2Foldchange > 1.0 and pvalue < 0.05, set as "UP" 
limma_results_30min$diffexpressed[limma_results_30min$logFC > 1.0 & limma_results_30min$adj.P.Val < 0.05 & limma_results_30min$P.Value < limma_results_30min$adj.P.Val] <- "UP"
# if log2Foldchange < -1.0 and pvalue < 0.05, set as "DOWN"
limma_results_30min$diffexpressed[limma_results_30min$logFC < -1.0 & limma_results_30min$adj.P.Val < 0.05 & limma_results_30min$P.Value < limma_results_30min$adj.P.Val] <- "DOWN"


limma_results_30min$difflabel <- NA
limma_results_30min$difflabel[limma_results_30min$diffexpressed != "NO"] <- rownames(limma_results_30min)[limma_results_30min$diffexpressed != "NO"]

```

```{r, warning=FALSE}
# Volcanoplot showing logFC/p-value for genes, comparing high(intercept) to low, so if a gene is upregulated in the volcano plot, its upregulated in high biliary viability compared to low biloiary viability
ggplot(data = limma_results_150min, 
       aes(x = logFC, 
           y = - log10(adj.P.Val), 
           col = diffexpressed, 
           label = difflabel)) +
  
  geom_point() + 
  theme_minimal() +
  geom_text_repel() +
  scale_color_manual(values=c("blue", "black", "red")) +
  geom_vline(xintercept=c(-1.0, 1.0), col="black") +
  geom_hline(yintercept=-log10(0.05), col="black") +
  scale_x_reverse()



ggplot(data = limma_results_30min, 
       aes(x = logFC, 
           y = - log10(adj.P.Val), 
           col = diffexpressed, 
           label = difflabel)) +
  
  geom_point() + 
  theme_minimal() +
  geom_text_repel() +
  scale_color_manual(values = c("blue", "black", "red")) +
  geom_vline(xintercept=c(-1.0, 1.0), col="black") +
  geom_hline(yintercept=-log10(0.05), col="black")

```

```{r}
upregulated_150min <- limma_results_150min %>% filter(diffexpressed =="UP")
upregulated_150min

downregulated_150min <- limma_results_150min %>% filter(diffexpressed =="DOWN")
downregulated_150min

```
# Pathway Analysis
## Subset on significant DEG's
```{r}
# Subset results for comparison, based on p-adjusted of 0.05 and/or below
diff_expressed_genes_150min <- limma_results_150min[!is.na (limma_results_150min$difflabel), ]
```

```{r}
# Create dataframe with corresponding entrez ID's for gene symbols
entrez_ID <- function(sig_df) {
  gene_names <- sig_df$difflabel
  genes_entrez <- AnnotationDbi::select(org.Hs.eg.db, keys = gene_names,
                                        columns = c('ENTREZID'), keytype = 'SYMBOL')
}

low_vs_high_150min_entrez <- entrez_ID(sig_df = diff_expressed_genes_150min)

```

```{r}
# Make dataframe that shows all pathways that have one or more DEG
pathway_low_vs_high_150min <- enrichKEGG(gene = low_vs_high_150min_entrez$ENTREZID,
                                         organism = 'hsa')

```

```{r}
# Make dataframe that contains log fold change ($logFC)
low_vs_high_150min_FC <- diff_expressed_genes_150min$logFC

# Add entrez ids as rownames to dataframe
names(low_vs_high_150min_FC) <- low_vs_high_150min_entrez$ENTREZID


```


```{r, eval=FALSE}
# Create visualisations for each pathway with at least 1 DEG, eval=FALSE because this can generate a lot of visualisations, depending on the amount of pathways
dir.create("pathview_output")
setwd("pathview_output")

# All pathways containing 1 or more DEP
pathways <- pathway_low_vs_high_150min@result

# All significantly pathways with 1 or more DEP's
significant_pathways <- pathways[pathways$p.adjust <= 0.05]

# Generate pathview visualisation for each significant pathway
for (pathway_id in rownames(significant_pathways)){
  print(paste("Processing pathway:", pathway_id))
  
  pathview(gene.data = low_vs_high_150min_FC, # chosen comparison
           pathway.id = pathway_id, # hsa ID
           species = "hsa", # human sapiens
           kegg.native = TRUE,
           low = list(gene="magenta"), # underexpressed = purple (colorblind friendly)
           high = list(gene="green"))  # overexpressed = green (colorblind friendly)
}

```

```{r}
# Adjust table for paper
# Add significance to values
diff_expressed_genes_150min$P.Value <- signif(diff_expressed_genes_150min$P.Value,3)
diff_expressed_genes_150min$t <- signif(diff_expressed_genes_150min$t,3)
diff_expressed_genes_150min$adj.P.Val <- formatC(diff_expressed_genes_150min$adj.P.Val,
                                                 format = "e",
                                                 digits = 2)
# Round values
diff_expressed_genes_150min$logFC <- round(diff_expressed_genes_150min$logFC,2)
diff_expressed_genes_150min$AveExpr <- round(diff_expressed_genes_150min$AveExpr,2)


diff_expressed_genes_150min$B <- round(diff_expressed_genes_150min$B,2)

# Order rows based on logFC
diff_expressed_genes_150min <-
  diff_expressed_genes_150min[order(diff_expressed_genes_150min$logFC),]

# Remove column that is not important to show in article
diff_expressed_genes_150min <- subset(diff_expressed_genes_150min, select = -difflabel)

colnames(diff_expressed_genes_150min) <- c("logFC", "Average Expression", "t", "p-value", "adjusted p-value", "B", "up/down regulated")

diff_expressed_genes_150min
save(diff_expressed_genes_150min, file = "diff_expressed_genes_table_150min.Rdata")

```

