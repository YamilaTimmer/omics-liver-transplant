---
title: "Logbook"
output: html_document
---
## Meta stuff

```{r}
list.of.packages <- c("ggplot2", "tidyverse", "mdatools")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

```

```{r}
library(ggplot2)
library(tidyverse)

```
## Data inlezen
### 14-05-2025


```{r}

load("/students/2024-2025/Thema08/liver-transplant/proteomics/count_data.Rdata")
load("/students/2024-2025/Thema08/liver-transplant/proteomics/meta_data.Rdata")
```


```{r}
na_mask <- is.na(data_filtered)
data_filtered[na_mask] <- 0
data_filtered
```

```{r}
meta_data_liver

```

Verwijder alle 0 variance metingen.
```{r}

X_t <- t(data_filtered)
variances <- apply(X_t, 2, var)
X_t <- X_t[, which(variances > 0)]
dim(X_t)
```


Transform and scale the data with log2 and scaling

```{r}
transformed <- log2(X_t + 1)
scaled <- scale(transformed, center = T, scale = T)
```

Covariances

```{r}
covmat <- cov(t(scaled))

```
Eigen
```{r}
eig <- eigen(covmat)

loadings <- t(scaled) %*% eig$vectors
loadings <- t(t(loadings) / sqrt(colSums(loadings^2)))
```


```{r}
scores <- scaled %*% loadings
scores_df <- as.data.frame(scores)
col_n <- seq(ncol(scores))
col_names <- paste0("PC", col_n)
names(scores_df) <- col_names
scores_df
```

```{r}
ggplot(
  scores_df,
  aes(x = PC1,
      y = PC2,
      color = meta_data_liver$`Biliary viability score group`,
      shape = meta_data_liver$Transplant),) +
  geom_point() +
  labs(color = "Billiary viability score")

```
Explained variances

```{r}
explained_var <- as.data.frame(eig$values / sum(eig$values)) * 100
explained_var$PC <- paste0("PC", col_n)
names(explained_var) <- c("ex_var","PC")
explained_var
```


```{r}
ggplot(explained_var[1:20,],
       aes(x = PC,
           y = ex_var)) +
  geom_col()

```

## PCA met mdatools
### 18-05-2025

Om te vergelijken of MDA tools een ander resultaat geeft wil ik de PCA uitvoeren met deze tool en vergelijken met mijn eigen uitgevoerde PCA.

```{r}
library(mdatools)

```


```{r}
model <- pca(transformed, center = T, scale = T, info ="Test PCA model")
model$ncomp
```


```{r}

plotScores(model, )
```


```{r}
ggplot(
  model$res$cal$scores,
  aes(x = `Comp 1`,
      y = `Comp 2`,
      color = meta_data_liver$`Biliary viability score group`,
      shape = meta_data_liver$Transplant),) +
  geom_point() +
  labs(color = "Billiary viability score")
```
Naast dat de plot geflipped is ziet deze er hetzelfde uit als mijn eigen gegenereerde PCA plot, dit houd in dat ik deze tool kan gaan gebruiken om de data te verwerken

### Echte data PCA
Voorheen was er data gebruikt waar nog geen imputatie op gebruikt was. Yamila heeft een nieuwe dataset gedeeld waarbij alle NA-waarden geimputeerd zijn. Hier zal ik opnieuw een PCA op uitvoeren.

#### Laden data
```{r}
load("/students/2024-2025/Thema08/liver-transplant/proteomics/normalized_imputed_count_data.Rdata")
```

Omdat deze data niet meer past bij de metadata ga ik zelf high en low values uit de naam halen.

```{r}
library(stringr)
```

```{r}
df_data <- as.data.frame(assay_norm)

bil_via <- str_extract(names(df_data), "[^_]+")
sample_names <- str_extract(names(df_data), "_(.*)") %>%
  str_replace("^_", "")
sample_names
```

```{r}
meta_data_liver_filtered <- meta_data_liver %>%
  dplyr::filter((Sample %in% sample_names) & (Timepoint == '30min'))

meta_data_liver_filtered

```

Nu komt de metadata overeen met de nieuwe gefilterde data. Deze kan nu gebruikt worden om kleuren te geven in plots, en zo kan er beter groepen weergegeven worden.


```{r}
df_data <- df_data %>%
  tibble::rownames_to_column("protein")

```

```{r}
model <- pca(t(assay_norm), center = T, scale = T)
```

```{r}
ggplot(
  model$res$cal$scores,
  aes(x = `Comp 1`,
      y = `Comp 2`,
      color = meta_data_liver_filtered$`Biliary viability score group`,
      shape = meta_data_liver_filtered$Transplant),) +
  geom_point() +
  labs(color = "Billiary viability score",
       shape = "Transplanted")
```
In deze plot zijn een aantal dingen zichtbaar:

- Een hogere viability houd vaak in dat de lever getransplanteerd is.
- De PCA geeft niet een duidelijke seperatie weer tussen de 2 groepen.
- Hoge viability is iets meer verspreid dan laag
- 1 lage viability ligt ver weg van alle andere punten.
- De meeste punten liggen bij elkaar rond de origin
- PLS-DA kan aangeraden worden om hier beter naar te kijken.

Imputatie kan verklaren waarom de meeste punten gewoon bij elkaar liggen.
Ik wil graag noteren welke sample die blauwe is aan de rechterkant. Later tijdens de DEP analyse kunnen we die mogelijk ook bekijken.

```{r}
scores_df <- as.data.frame(model$res$cal$scores)

low_bil_value <- meta_data_liver_filtered %>%
  dplyr::filter(`Biliary viability score group` == "Low")

standout_low_sample <- scores_df %>%
  tibble::rownames_to_column("Sample") %>%
  mutate(Sample = sub("^[^_]+_", "", Sample)) %>%
  dplyr::filter(Sample %in% low_bil_value$Sample) %>%
  dplyr::filter(`Comp 1` == max(`Comp 1`))

standout_low_sample
```
Hieruit zien we dat NMP_Bile_Proteomics_48 de grote outlier is, deze kunnen we bij volgende stappen in de gaten houden.

Nu wil ik zien hoeveel van de variantie verklaard wordt door de 1e 20 prinipale componenten.

```{r}
plotVariance(model)
```

Dit geeft weer dat component 1 ongeveer 21% van de variantie verklaard
PC-2 rond de 9, en vanaf PC-5 is het < 5%.

Ik wil nu de top 20 proteins weergeven van PC-1

```{r}
loadings <- model$loadings
loadings$pc1 <- loadings[,1]

plot(loadings$pc1)
```


```{r}
argsort <- order(loadings$pc1^2, decreasing = T)
plot(loadings$pc1[argsort])
```

```{r}
top_x_genes <- df_data[argsort[1:100], 1]
top_x_genes
```

Dit zijn de top 100 genen


### Mapping transcriptomics data
Jarno loopt tegen een probleem dat maar 35% van onze data gemapped kan worden, ik zal bepalen hoe dit kan. Eerst ga ik de kwaliteit van de fastq data bepalen.
Dit ga ik doen met Falco en multiqc

```{bash, eval = FALSE}
ls /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/ | \
parallel "/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/tools/bin/falco /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/{} -o /students/2024-2025/Thema08/liver-transplant/transcriptomics/falco/{}_fastqc_report"
```


```{bash, eval = FALSE}
multiqc /students/2024-2025/Thema08/liver-transplant/transcriptomics/falco/* -o /students/2024-2025/Thema08/liver-transplant/transcriptomics/multiqc/
```


### 19-05-2025

```{bash, eval = FALSE}
cat /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/mouse_cell_SRR.txt | \
    parallel 'STAR --runThreadN 6 ' \
        '--genomeDir /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/tools/star/index_GRCm39/ ' \
        '--readFilesIn /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/ERR12161053_1.fastq.gz /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/ERR12161053_2.fastq.gz ' \
        '--outSAMtype BAM SortedByCoordinate ' \
        '--quantMode GeneCounts ' \
        '--genomeLoad LoadAndRemove' \
        '--limitBAMsortRAM 2000000000 ' \
        '--outFileNamePrefix /students/2024-2025/Thema08/liver-transplant/transcriptomics/STAR/test_star_'

```


```{bash, eval = FALSE}
STAR --runThreadN 6 --genomeDir /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/tools/star/index_GRCm39/ --readFilesIn /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/ERR12161053_1.fastq /students/2024-2025/Thema08/liver-transplant/transcriptomics/fastq_data/ERR12161053_2.fastq --outSAMtype BAM SortedByCoordinate --quantMode GeneCounts --genomeLoad LoadAndRemove --limitBAMsortRAM 2000000000 --outFileNamePrefix /students/2024-2025/Thema08/liver-transplant/transcriptomics/STAR/test_star_

```

## Pca 150 minute data

```{r}
load("/students/2024-2025/Thema08/liver-transplant/proteomics/count_data.Rdata")
```


```{bash, eval = FALSE}
echo hoi
```